MAIN      START
          CALL    INPUT
          POP     GR0 ; result
          RET
          END

;-------------------------------------------------------
; OUTPUT(n) -> void. args: [n, RETURN], RETURN: [RETURN]
OUTPUT    START
          POP     GR7
          
          PUSH    0, GR7
          RET
          END

;-------------------------------------------------------
; INPUT() -> number. args: [RETURN], return: [number, RETURN]
INPUT     START
          POP     GR7
          IN      IBUF, ILEN
          LD      GR1, ILEN ; GR1 = i = ILEN (1桁目から始める)
          SUBA    GR1, ONE ; i -= 1
          LAD     GR2, #0001 ; GR2 = 10^i
          XOR     GR3, GR3 ; GR3 = result
          LD      GR4, MINUS
          CPA     GR4, IBUF ; GR4 == '-'
          JNZ     NEXT
          LAD     GR4, 1 ; GR4 = 負の数(1)
          ADDA    GR1, ONE ; i++
NEXT      LAD     GR4, 0 ; GR4 = 正の数(0)
; i = ILEN - 1, i >= 0; i--
LOOP      CPA     GR1, ZERO
          JMI     BREAK ; i < 0 なら抜ける
          LAD     GR5, #000F
          AND     GR5, IBUF, GR1 ; GR5 = i桁目の数字

          PUSH    0, GR1 ; 退避
          PUSH    0, GR3 ; 退避
          PUSH    0, GR4 ; 退避
          PUSH    0, GR7
          PUSH    0, GR2 ; 退避
          PUSH    0, GR2 ; 10^i
          PUSH    0, GR5 ; i桁目の数字
          CALL    MULT
          POP     GR5 ; かけ算結果
          POP     GR2 ; 10^i
          PUSH    0, GR5 ; GR2とGR5の順番入れ替え
          PUSH    0, GR2
          LAD     GR1, 10 ; 10をPUSH
          PUSH    0, GR1
          CALL    MULT
          POP     GR2
          POP     GR5
          POP     GR7
          POP     GR4 ; 復帰
          POP     GR3 ; 復帰
          POP     GR1 ; 復帰

          ADDA    GR3, GR5 ; result += GR5
          SUBA    GR1, ONE ; i--
          JUMP    LOOP
BREAK     PUSH    0, GR3 ; result
          PUSH    0, GR7
          RET
IBUF      DS      6       ; -32768-32767なので6
ILEN      DS      1
MINUS     DC      '-'
ZERO      DC      0
ONE       DC      1
          END

;-------------------------------------------------------
; MULT(a, b) -> a * b. args: [a, b, RETURN], return: [result, RETURN]
; use: GR1, GR2, GR3, GR4, GR5, GR7
MULT      START
          POP     GR7 ; GR7 = RETURN
          POP     GR2 ; GR2 = b
          POP     GR1 ; GR1 = a

          LD      GR4, GR1 ; GR4 = 負の数かどうか
          XOR     GR4, GR2
          SRL     GR4, 15

          PUSH    0, GR1
          PUSH    0, GR4
          PUSH    0, GR7
          PUSH    0, GR2 ; b = |b|
          CALL    ABS
          POP     GR2
          POP     GR7
          POP     GR4
          POP     GR1

          PUSH    0, GR2
          PUSH    0, GR4
          PUSH    0, GR7
          PUSH    0, GR1 ; a = |a|
          CALL    ABS
          POP     GR1
          POP     GR7
          POP     GR4
          POP     GR2

          XOR     GR3, GR3 ; GR3 = result

LOOP      CPA     GR2, =0 ; b == 0 ?
          JZE     BREAK ;b == 0なら抜ける
          LD      GR5, GR2 ; bをGR4にコピー
          AND     GR5, ONE ; b &= 1
          JZE     NEXT ; b の1bit目が0ならNEXTへ
          ADDA    GR3, GR1 ; result += a を左シフトしたもの
NEXT      SRL     GR2, 1 ; b >> 1
          SLL     GR1, 1 ; a << 1
          JUMP    LOOP
BREAK     CPA     GR4, ONE ; GR4が1 (aとbのどちらかが負) ならば
          JNZ     NOTMINUS
          XOR     GR3, MASK ; GR3を負にする
          ADDA    GR3, ONE
NOTMINUS  PUSH    0, GR3 ; result
          PUSH    0, GR7 ; RETURN
          RET
ONE       DC      1
MASK      DC      #FFFF
          END

;-------------------------------------------------------

ABS       START ; ABS(a) -> |a|. args: [a, RETURN], return: [|a|, RETURN]
          POP     GR7 ; GR7 = RETURN
          POP     GR1 ; GR0 = a
          CPA     GR1, ZERO
          JPL     ONPLUS ; GR0 > 0 なら抜ける
          XOR     GR1, MASK ; 符号反転
          ADDA    GR1, ONE
ONPLUS    PUSH    0, GR1
          PUSH    0, GR7
          RET
ZERO      DC      0
ONE       DC      1
MASK      DC      #FFFF
          END